/*
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// This file is automatically generated. Do not modify it.
package com.kyant.aura.core.hct

import com.kyant.aura.core.hct.Cam16.Companion.LINRGB_FROM_SCALED_DISCOUNT_11
import com.kyant.aura.core.hct.Cam16.Companion.LINRGB_FROM_SCALED_DISCOUNT_12
import com.kyant.aura.core.hct.Cam16.Companion.LINRGB_FROM_SCALED_DISCOUNT_13
import com.kyant.aura.core.hct.Cam16.Companion.LINRGB_FROM_SCALED_DISCOUNT_21
import com.kyant.aura.core.hct.Cam16.Companion.LINRGB_FROM_SCALED_DISCOUNT_22
import com.kyant.aura.core.hct.Cam16.Companion.LINRGB_FROM_SCALED_DISCOUNT_23
import com.kyant.aura.core.hct.Cam16.Companion.LINRGB_FROM_SCALED_DISCOUNT_31
import com.kyant.aura.core.hct.Cam16.Companion.LINRGB_FROM_SCALED_DISCOUNT_32
import com.kyant.aura.core.hct.Cam16.Companion.LINRGB_FROM_SCALED_DISCOUNT_33
import com.kyant.aura.core.hct.Cam16.Companion.SCALED_DISCOUNT_FROM_LINRGB_11
import com.kyant.aura.core.hct.Cam16.Companion.SCALED_DISCOUNT_FROM_LINRGB_12
import com.kyant.aura.core.hct.Cam16.Companion.SCALED_DISCOUNT_FROM_LINRGB_13
import com.kyant.aura.core.hct.Cam16.Companion.SCALED_DISCOUNT_FROM_LINRGB_21
import com.kyant.aura.core.hct.Cam16.Companion.SCALED_DISCOUNT_FROM_LINRGB_22
import com.kyant.aura.core.hct.Cam16.Companion.SCALED_DISCOUNT_FROM_LINRGB_23
import com.kyant.aura.core.hct.Cam16.Companion.SCALED_DISCOUNT_FROM_LINRGB_31
import com.kyant.aura.core.hct.Cam16.Companion.SCALED_DISCOUNT_FROM_LINRGB_32
import com.kyant.aura.core.hct.Cam16.Companion.SCALED_DISCOUNT_FROM_LINRGB_33
import com.kyant.aura.core.utils.ColorUtils
import com.kyant.aura.core.utils.ColorUtils.Y_FROM_LINRGB_B
import com.kyant.aura.core.utils.ColorUtils.Y_FROM_LINRGB_G
import com.kyant.aura.core.utils.ColorUtils.Y_FROM_LINRGB_R
import com.kyant.aura.core.utils.MathUtils
import kotlin.math.abs
import kotlin.math.atan2
import kotlin.math.ceil
import kotlin.math.cos
import kotlin.math.floor
import kotlin.math.hypot
import kotlin.math.max
import kotlin.math.pow
import kotlin.math.sin
import kotlin.math.sqrt

/**
 * A class that solves the HCT equation.
 */
internal object HctSolver {
    private const val MAX_CHROMA_VALUE = 200.0

    private val CRITICAL_PLANES: DoubleArray = doubleArrayOf(
        0.015176349177441876,
        0.045529047532325624,
        0.07588174588720938,
        0.10623444424209313,
        0.13658714259697685,
        0.16693984095186062,
        0.19729253930674434,
        0.2276452376616281,
        0.2579979360165119,
        0.28835063437139563,
        0.3188300904430532,
        0.350925934958123,
        0.3848314933096426,
        0.42057480301049466,
        0.458183274052838,
        0.4976837250274023,
        0.5391024159806381,
        0.5824650784040898,
        0.6277969426914107,
        0.6751227633498623,
        0.7244668422128921,
        0.775853049866786,
        0.829304845476233,
        0.8848452951698498,
        0.942497089126609,
        1.0022825574869039,
        1.0642236851973577,
        1.1283421258858297,
        1.1946592148522128,
        1.2631959812511864,
        1.3339731595349034,
        1.407011200216447,
        1.4823302800086415,
        1.5599503113873272,
        1.6398909516233677,
        1.7221716113234105,
        1.8068114625156377,
        1.8938294463134073,
        1.9832442801866852,
        2.075074464868551,
        2.1693382909216234,
        2.2660538449872063,
        2.36523901573795,
        2.4669114995532007,
        2.5710888059345764,
        2.6777882626779785,
        2.7870270208169257,
        2.898822059350997,
        3.0131901897720907,
        3.1301480604002863,
        3.2497121605402226,
        3.3718988244681087,
        3.4967242352587946,
        3.624204428461639,
        3.754355295633311,
        3.887192587735158,
        4.022731918402185,
        4.160988767090289,
        4.301978482107941,
        4.445716283538092,
        4.592217266055746,
        4.741496401646282,
        4.893568542229298,
        5.048448422192488,
        5.20615066083972,
        5.3666897647573375,
        5.5300801301023865,
        5.696336044816294,
        5.865471690767354,
        6.037501145825082,
        6.212438385869475,
        6.390297286737924,
        6.571091626112461,
        6.7548350853498045,
        6.941541251256611,
        7.131223617812143,
        7.323895587840543,
        7.5195704746346665,
        7.7182615035334345,
        7.919981813454504,
        8.124744458384042,
        8.332562408825165,
        8.543448553206703,
        8.757415699253682,
        8.974476575321063,
        9.194643831691977,
        9.417930041841839,
        9.644347703669503,
        9.873909240696694,
        10.106627003236781,
        10.342513269534024,
        10.58158024687427,
        10.8238400726681,
        11.069304815507364,
        11.317986476196008,
        11.569896988756009,
        11.825048221409341,
        12.083451977536606,
        12.345119996613247,
        12.610063955123938,
        12.878295467455942,
        13.149826086772048,
        13.42466730586372,
        13.702830557985108,
        13.984327217668513,
        14.269168601521828,
        14.55736596900856,
        14.848930523210871,
        15.143873411576273,
        15.44220572664832,
        15.743938506781891,
        16.04908273684337,
        16.35764934889634,
        16.66964922287304,
        16.985093187232053,
        17.30399201960269,
        17.62635644741625,
        17.95219714852476,
        18.281524751807332,
        18.614349837764564,
        18.95068293910138,
        19.290534541298456,
        19.633915083172692,
        19.98083495742689,
        20.331304511189067,
        20.685334046541502,
        21.042933821039977,
        21.404114048223256,
        21.76888489811322,
        22.137256497705877,
        22.50923893145328,
        22.884842241736916,
        23.264076429332462,
        23.6469514538663,
        24.033477234264016,
        24.42366364919083,
        24.817520537484558,
        25.21505769858089,
        25.61628489293138,
        26.021211842414342,
        26.429848230738664,
        26.842203703840827,
        27.258287870275353,
        27.678110301598522,
        28.10168053274597,
        28.529008062403893,
        28.96010235337422,
        29.39497283293396,
        29.83362889318845,
        30.276079891419332,
        30.722335150426627,
        31.172403958865512,
        31.62629557157785,
        32.08401920991837,
        32.54558406207592,
        33.010999283389665,
        33.4802739966603,
        33.953417292456834,
        34.430438229418264,
        34.911345834551085,
        35.39614910352207,
        35.88485700094671,
        36.37747846067349,
        36.87402238606382,
        37.37449765026789,
        37.87891309649659,
        38.38727753828926,
        38.89959975977785,
        39.41588851594697,
        39.93615253289054,
        40.460400508064545,
        40.98864111053629,
        41.520882981230194,
        42.05713473317016,
        42.597404951718396,
        43.141702194811224,
        43.6900349931913,
        44.24241185063697,
        44.798841244188324,
        45.35933162437017,
        45.92389141541209,
        46.49252901546552,
        47.065252796817916,
        47.64207110610409,
        48.22299226451468,
        48.808024568002054,
        49.3971762874833,
        49.9904556690408,
        50.587870934119984,
        51.189430279724725,
        51.79514187861014,
        52.40501387947288,
        53.0190544071392,
        53.637271562750364,
        54.259673423945976,
        54.88626804504493,
        55.517063457223934,
        56.15206766869424,
        56.79128866487574,
        57.43473440856916,
        58.08241284012621,
        58.734331877617365,
        59.39049941699807,
        60.05092333227251,
        60.715611475655585,
        61.38457167773311,
        62.057811747619894,
        62.7353394731159,
        63.417162620860914,
        64.10328893648692,
        64.79372614476921,
        65.48848194977529,
        66.18756403501224,
        66.89098006357258,
        67.59873767827808,
        68.31084450182222,
        69.02730813691093,
        69.74813616640164,
        70.47333615344107,
        71.20291564160104,
        71.93688215501312,
        72.67524319850172,
        73.41800625771542,
        74.16517879925733,
        74.9167682708136,
        75.67278210128072,
        76.43322770089146,
        77.1981124613393,
        77.96744375590167,
        78.74122893956174,
        79.51947534912904,
        80.30219030335869,
        81.08938110306934,
        81.88105503125999,
        82.67721935322541,
        83.4778813166706,
        84.28304815182372,
        85.09272707154808,
        85.90692527145302,
        86.72564993000343,
        87.54890820862819,
        88.3767072518277,
        89.2090541872801,
        90.04595612594655,
        90.88742016217518,
        91.73345337380438,
        92.58406282226491,
        93.43925555268066,
        94.29903859396902,
        95.16341895893969,
        96.03240364439274,
        96.9059996312159,
        97.78421388448044,
        98.6670533535366,
        99.55452497210776,
    )

    /**
     * Delinearizes an RGB component, returning a floating-point number.
     *
     * @param rgbComponent 0.0 <= rgb_component <= 100.0, represents linear R/G/B channel
     * @return 0.0 <= output <= 255.0, color channel converted to regular RGB space
     */
    @JvmStatic
    private fun trueDelinearized(rgbComponent: Double): Double {
        val normalized = rgbComponent / 100.0
        val delinearized =
            if (normalized <= 0.0031308) {
                normalized * 12.92
            } else {
                1.055 * normalized.pow(1.0 / 2.4) - 0.055
            }
        return delinearized * 255.0
    }

    /**
     * Returns the hue of a linear RGB color in CAM16.
     *
     * @param linrgbR The R channel of the color.
     * @param linrgbG The G channel of the color.
     * @param linrgbB The B channel of the color.
     * @return The hue of the color in CAM16, in radians.
     */
    @JvmStatic
    private fun hueOf(linrgbR: Double, linrgbG: Double, linrgbB: Double): Double {
        val rDScaled =
            linrgbR * SCALED_DISCOUNT_FROM_LINRGB_11 +
                    linrgbG * SCALED_DISCOUNT_FROM_LINRGB_12 +
                    linrgbB * SCALED_DISCOUNT_FROM_LINRGB_13
        val gDScaled =
            linrgbR * SCALED_DISCOUNT_FROM_LINRGB_21 +
                    linrgbG * SCALED_DISCOUNT_FROM_LINRGB_22 +
                    linrgbB * SCALED_DISCOUNT_FROM_LINRGB_23
        val bDScaled =
            linrgbR * SCALED_DISCOUNT_FROM_LINRGB_31 +
                    linrgbG * SCALED_DISCOUNT_FROM_LINRGB_32 +
                    linrgbB * SCALED_DISCOUNT_FROM_LINRGB_33
        val rAF = rDScaled.pow(0.42)
        val gAF = gDScaled.pow(0.42)
        val bAF = bDScaled.pow(0.42)
        val rAScaled = rAF / (rAF + 27.13)
        val gAScaled = gAF / (gAF + 27.13)
        val bAScaled = bAF / (bAF + 27.13)
        val aScaled = 9.0 * rAScaled - 108.0 / 11.0 * gAScaled + 9.0 / 11.0 * bAScaled
        val bScaled = rAScaled + gAScaled - bAScaled - bAScaled
        return atan2(bScaled, aScaled)
    }

    @Suppress("NOTHING_TO_INLINE")
    @JvmStatic
    private inline fun areInCyclicOrder(a: Double, b: Double, c: Double): Boolean {
        val deltaAB = (b - a + Math.PI * 8) % (Math.PI * 2)
        val deltaAC = (c - a + Math.PI * 8) % (Math.PI * 2)
        return deltaAB < deltaAC
    }

    /**
     * Finds a color with the given Y and hue on the boundary of the cube.
     *
     * @param y         The Y value of the color.
     * @param targetHue The hue of the color.
     * @return A hexadecimal representing the desired sRGB color.
     */
    @JvmStatic
    private fun bisectToLimit(y: Double, targetHue: Double): Int {
        var leftR = 0.0
        var leftG = 0.0
        var leftB = 0.0
        var rightR = 0.0
        var rightG = 0.0
        var rightB = 0.0
        var leftHue = 0.0
        var rightHue = 0.0
        var midR = 0.0
        var midG = 0.0
        var midB = 0.0
        var midHue = 0.0

        /*
        n = 0, coordA = 0.0, coordB = 0.0
        n = 1, coordA = 0.0, coordB = 100.0
        n = 2, coordA = 100.0, coordB = 0.0
        n = 3, coordA = 100.0, coordB = 100.0
        n = 4, coordA = 0.0, coordB = 0.0
        n = 5, coordA = 0.0, coordB = 100.0
        n = 6, coordA = 100.0, coordB = 0.0
        n = 7, coordA = 100.0, coordB = 100.0
        n = 8, coordA = 0.0, coordB = 0.0
        n = 9, coordA = 0.0, coordB = 100.0
        n = 10, coordA = 100.0, coordB = 0.0
        n = 11, coordA = 100.0, coordB = 100.0
         */

        /*when (y) {
            in 0.0..7.22 -> listOf(
                doubleArrayOf(y / Y_FROM_LINRGB_R, 0.0, 0.0),
                doubleArrayOf(0.0, y / Y_FROM_LINRGB_G, 0.0),
                doubleArrayOf(0.0, 0.0, y / Y_FROM_LINRGB_B),
            )

            in 7.22..21.26 -> listOf(
                doubleArrayOf(y / Y_FROM_LINRGB_R, 0.0, 0.0),
                doubleArrayOf((y - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_R, 0.0, 100.0),
                doubleArrayOf(0.0, y / Y_FROM_LINRGB_G, 0.0),
                doubleArrayOf(0.0, (y - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G, 100.0),
            )

            in 21.26..28.48 -> listOf(
                doubleArrayOf((y - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_R, 0.0, 100.0),
                doubleArrayOf(0.0, y / Y_FROM_LINRGB_G, 0.0),
                doubleArrayOf(100.0, (y - 100.0 * Y_FROM_LINRGB_R) / Y_FROM_LINRGB_G, 0.0),
                doubleArrayOf(0.0, (y - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G, 100.0),
                doubleArrayOf(100.0, 0.0, (y - 100.0 * Y_FROM_LINRGB_R) / Y_FROM_LINRGB_B),
            )

            in 28.48..71.52 -> listOf(
                doubleArrayOf(0.0, y / Y_FROM_LINRGB_G, 0.0),
                doubleArrayOf(100.0, (y - 100.0 * Y_FROM_LINRGB_R) / Y_FROM_LINRGB_G, 0.0),
                doubleArrayOf(0.0, (y - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G, 100.0),
                doubleArrayOf(100.0, (y - 100.0 * Y_FROM_LINRGB_R - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G, 100.0),
            )

            in 71.52..78.74 -> listOf(
                doubleArrayOf((y - 100.0 * Y_FROM_LINRGB_G) / Y_FROM_LINRGB_R, 100.0, 0.0),
                doubleArrayOf(100.0, (y - 100.0 * Y_FROM_LINRGB_R) / Y_FROM_LINRGB_G, 0.0),
                doubleArrayOf(0.0, (y - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G, 100.0),
                doubleArrayOf(100.0, (y - 100.0 * Y_FROM_LINRGB_R - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G, 100.0),
                doubleArrayOf(0.0, 100.0, (y - 100.0 * Y_FROM_LINRGB_G) / Y_FROM_LINRGB_B),
            )

            in 78.74..92.78 -> listOf(
                doubleArrayOf((y - 100.0 * Y_FROM_LINRGB_G) / Y_FROM_LINRGB_R, 100.0, 0.0),
                doubleArrayOf((y - 100.0 * Y_FROM_LINRGB_G - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_R, 100.0, 100.0),
                doubleArrayOf(100.0, (y - 100.0 * Y_FROM_LINRGB_R) / Y_FROM_LINRGB_G, 0.0),
                doubleArrayOf(100.0, (y - 100.0 * Y_FROM_LINRGB_R - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G, 100.0),
            )

            in 92.78..100.0 -> listOf(
                doubleArrayOf((y - 100.0 * Y_FROM_LINRGB_G - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_R, 100.0, 100.0),
                doubleArrayOf(100.0, (y - 100.0 * Y_FROM_LINRGB_R - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G, 100.0),
                doubleArrayOf(100.0, 100.0, (y - 100.0 * Y_FROM_LINRGB_R - 100.0 * Y_FROM_LINRGB_G) / Y_FROM_LINRGB_B),
            )

            else -> throw IllegalArgumentException("Y value out of range: $y")
        }*/

        when (y) {
            in 0.0..7.22 -> {
                // update(y / Y_FROM_LINRGB_R, 0.0, 0.0)
                midR = y / Y_FROM_LINRGB_R
                midG = 0.0
                midB = 0.0
                midHue = hueOf(midR, midG, midB)
                leftR = midR
                leftG = midG
                leftB = midB
                rightR = midR
                rightG = midG
                rightB = midB
                leftHue = midHue
                rightHue = midHue

                // update(0.0, y / Y_FROM_LINRGB_G, 0.0)
                midR = 0.0
                midG = y / Y_FROM_LINRGB_G
                midB = 0.0
                midHue = hueOf(midR, midG, midB)
                if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                    rightR = midR
                    rightG = midG
                    rightB = midB
                    rightHue = midHue
                } else {
                    leftR = midR
                    leftG = midG
                    leftB = midB
                    leftHue = midHue
                }

                // update(0.0, 0.0, y / Y_FROM_LINRGB_B)
                midR = 0.0
                midG = 0.0
                midB = y / Y_FROM_LINRGB_B
                midHue = hueOf(midR, midG, midB)
                if (areInCyclicOrder(leftHue, midHue, rightHue)) {
                    if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                        rightR = midR
                        rightG = midG
                        rightB = midB
                        rightHue = midHue
                    } else {
                        leftR = midR
                        leftG = midG
                        leftB = midB
                        leftHue = midHue
                    }
                }
            }

            in 7.22..21.26 -> {
                // update(y / Y_FROM_LINRGB_R, 0.0, 0.0)
                midR = y / Y_FROM_LINRGB_R
                midG = 0.0
                midB = 0.0
                midHue = hueOf(midR, midG, midB)
                leftR = midR
                leftG = midG
                leftB = midB
                rightR = midR
                rightG = midG
                rightB = midB
                leftHue = midHue
                rightHue = midHue

                // update((y - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_R, 0.0, 100.0)
                midR = (y - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_R
                midG = 0.0
                midB = 100.0
                midHue = hueOf(midR, midG, midB)
                if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                    rightR = midR
                    rightG = midG
                    rightB = midB
                    rightHue = midHue
                } else {
                    leftR = midR
                    leftG = midG
                    leftB = midB
                    leftHue = midHue
                }

                // update(0.0, y / Y_FROM_LINRGB_G, 0.0)
                midR = 0.0
                midG = y / Y_FROM_LINRGB_G
                midB = 0.0
                midHue = hueOf(midR, midG, midB)
                if (areInCyclicOrder(leftHue, midHue, rightHue)) {
                    if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                        rightR = midR
                        rightG = midG
                        rightB = midB
                        rightHue = midHue
                    } else {
                        leftR = midR
                        leftG = midG
                        leftB = midB
                        leftHue = midHue
                    }
                }

                // update(0.0, (y - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G, 100.0)
                midR = 0.0
                midG = (y - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G
                midB = 100.0
                midHue = hueOf(midR, midG, midB)
                if (areInCyclicOrder(leftHue, midHue, rightHue)) {
                    if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                        rightR = midR
                        rightG = midG
                        rightB = midB
                        rightHue = midHue
                    } else {
                        leftR = midR
                        leftG = midG
                        leftB = midB
                        leftHue = midHue
                    }
                }
            }

            in 21.26..28.48 -> {
                // update((y - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_R, 0.0, 100.0)
                midR = (y - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_R
                midG = 0.0
                midB = 100.0
                midHue = hueOf(midR, midG, midB)
                leftR = midR
                leftG = midG
                leftB = midB
                rightR = midR
                rightG = midG
                rightB = midB
                leftHue = midHue
                rightHue = midHue

                // update(0.0, y / Y_FROM_LINRGB_G, 0.0)
                midR = 0.0
                midG = y / Y_FROM_LINRGB_G
                midB = 0.0
                midHue = hueOf(midR, midG, midB)
                if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                    rightR = midR
                    rightG = midG
                    rightB = midB
                    rightHue = midHue
                } else {
                    leftR = midR
                    leftG = midG
                    leftB = midB
                    leftHue = midHue
                }

                // update(100.0, (y - 100.0 * Y_FROM_LINRGB_R) / Y_FROM_LINRGB_G, 0.0)
                midR = 100.0
                midG = (y - 100.0 * Y_FROM_LINRGB_R) / Y_FROM_LINRGB_G
                midB = 0.0
                midHue = hueOf(midR, midG, midB)
                if (areInCyclicOrder(leftHue, midHue, rightHue)) {
                    if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                        rightR = midR
                        rightG = midG
                        rightB = midB
                        rightHue = midHue
                    } else {
                        leftR = midR
                        leftG = midG
                        leftB = midB
                        leftHue = midHue
                    }
                }

                // update(0.0, (y - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G, 100.0)
                midR = 0.0
                midG = (y - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G
                midB = 100.0
                midHue = hueOf(midR, midG, midB)
                if (areInCyclicOrder(leftHue, midHue, rightHue)) {
                    if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                        rightR = midR
                        rightG = midG
                        rightB = midB
                        rightHue = midHue
                    } else {
                        leftR = midR
                        leftG = midG
                        leftB = midB
                        leftHue = midHue
                    }
                }

                // update(100.0, 0.0, (y - 100.0 * Y_FROM_LINRGB_R) / Y_FROM_LINRGB_B)
                midR = 100.0
                midG = 0.0
                midB = (y - 100.0 * Y_FROM_LINRGB_R) / Y_FROM_LINRGB_B
                midHue = hueOf(midR, midG, midB)
                if (areInCyclicOrder(leftHue, midHue, rightHue)) {
                    if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                        rightR = midR
                        rightG = midG
                        rightB = midB
                        rightHue = midHue
                    } else {
                        leftR = midR
                        leftG = midG
                        leftB = midB
                        leftHue = midHue
                    }
                }
            }

            in 28.48..71.52 -> {
                // update(0.0, y / Y_FROM_LINRGB_G, 0.0)
                midR = 0.0
                midG = y / Y_FROM_LINRGB_G
                midB = 0.0
                midHue = hueOf(midR, midG, midB)
                leftR = midR
                leftG = midG
                leftB = midB
                rightR = midR
                rightG = midG
                rightB = midB
                leftHue = midHue
                rightHue = midHue

                // update(100.0, (y - 100.0 * Y_FROM_LINRGB_R) / Y_FROM_LINRGB_G, 0.0)
                midR = 100.0
                midG = (y - 100.0 * Y_FROM_LINRGB_R) / Y_FROM_LINRGB_G
                midB = 0.0
                midHue = hueOf(midR, midG, midB)
                if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                    rightR = midR
                    rightG = midG
                    rightB = midB
                    rightHue = midHue
                } else {
                    leftR = midR
                    leftG = midG
                    leftB = midB
                    leftHue = midHue
                }

                // update(0.0, (y - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G, 100.0)
                midR = 0.0
                midG = (y - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G
                midB = 100.0
                midHue = hueOf(midR, midG, midB)
                if (areInCyclicOrder(leftHue, midHue, rightHue)) {
                    if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                        rightR = midR
                        rightG = midG
                        rightB = midB
                        rightHue = midHue
                    } else {
                        leftR = midR
                        leftG = midG
                        leftB = midB
                        leftHue = midHue
                    }
                }

                // update(100.0, (y - 100.0 * Y_FROM_LINRGB_R - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G, 100.0)
                midR = 100.0
                midG = (y - 100.0 * Y_FROM_LINRGB_R - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G
                midB = 100.0
                midHue = hueOf(midR, midG, midB)
                if (areInCyclicOrder(leftHue, midHue, rightHue)) {
                    if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                        rightR = midR
                        rightG = midG
                        rightB = midB
                        rightHue = midHue
                    } else {
                        leftR = midR
                        leftG = midG
                        leftB = midB
                        leftHue = midHue
                    }
                }
            }

            in 71.52..78.74 -> {
                // update((y - 100.0 * Y_FROM_LINRGB_G) / Y_FROM_LINRGB_R, 100.0, 0.0)
                midR = (y - 100.0 * Y_FROM_LINRGB_G) / Y_FROM_LINRGB_R
                midG = 100.0
                midB = 0.0
                midHue = hueOf(midR, midG, midB)
                leftR = midR
                leftG = midG
                leftB = midB
                rightR = midR
                rightG = midG
                rightB = midB
                leftHue = midHue
                rightHue = midHue

                // update(100.0, (y - 100.0 * Y_FROM_LINRGB_R) / Y_FROM_LINRGB_G, 0.0)
                midR = 100.0
                midG = (y - 100.0 * Y_FROM_LINRGB_R) / Y_FROM_LINRGB_G
                midB = 0.0
                midHue = hueOf(midR, midG, midB)
                if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                    rightR = midR
                    rightG = midG
                    rightB = midB
                    rightHue = midHue
                } else {
                    leftR = midR
                    leftG = midG
                    leftB = midB
                    leftHue = midHue
                }

                // update(0.0, (y - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G, 100.0)
                midR = 0.0
                midG = (y - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G
                midB = 100.0
                midHue = hueOf(midR, midG, midB)
                if (areInCyclicOrder(leftHue, midHue, rightHue)) {
                    if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                        rightR = midR
                        rightG = midG
                        rightB = midB
                        rightHue = midHue
                    } else {
                        leftR = midR
                        leftG = midG
                        leftB = midB
                        leftHue = midHue
                    }
                }

                // update(100.0, (y - 100.0 * Y_FROM_LINRGB_R - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G, 100.0)
                midR = 100.0
                midG = (y - 100.0 * Y_FROM_LINRGB_R - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G
                midB = 100.0
                midHue = hueOf(midR, midG, midB)
                if (areInCyclicOrder(leftHue, midHue, rightHue)) {
                    if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                        rightR = midR
                        rightG = midG
                        rightB = midB
                        rightHue = midHue
                    } else {
                        leftR = midR
                        leftG = midG
                        leftB = midB
                        leftHue = midHue
                    }
                }

                // update(0.0, 100.0, (y - 100.0 * Y_FROM_LINRGB_G) / Y_FROM_LINRGB_B)
                midR = 0.0
                midG = 100.0
                midB = (y - 100.0 * Y_FROM_LINRGB_G) / Y_FROM_LINRGB_B
                midHue = hueOf(midR, midG, midB)
                if (areInCyclicOrder(leftHue, midHue, rightHue)) {
                    if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                        rightR = midR
                        rightG = midG
                        rightB = midB
                        rightHue = midHue
                    } else {
                        leftR = midR
                        leftG = midG
                        leftB = midB
                        leftHue = midHue
                    }
                }
            }

            in 78.74..92.78 -> {
                // update((y - 100.0 * Y_FROM_LINRGB_G) / Y_FROM_LINRGB_R, 100.0, 0.0)
                midR = (y - 100.0 * Y_FROM_LINRGB_G) / Y_FROM_LINRGB_R
                midG = 100.0
                midB = 0.0
                midHue = hueOf(midR, midG, midB)
                leftR = midR
                leftG = midG
                leftB = midB
                rightR = midR
                rightG = midG
                rightB = midB
                leftHue = midHue
                rightHue = midHue

                // update((y - 100.0 * Y_FROM_LINRGB_G - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_R, 100.0, 100.0)
                midR = (y - 100.0 * Y_FROM_LINRGB_G - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_R
                midG = 100.0
                midB = 100.0
                midHue = hueOf(midR, midG, midB)
                if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                    rightR = midR
                    rightG = midG
                    rightB = midB
                    rightHue = midHue
                } else {
                    leftR = midR
                    leftG = midG
                    leftB = midB
                    leftHue = midHue
                }

                // update(100.0, (y - 100.0 * Y_FROM_LINRGB_R) / Y_FROM_LINRGB_G, 0.0)
                midR = 100.0
                midG = (y - 100.0 * Y_FROM_LINRGB_R) / Y_FROM_LINRGB_G
                midB = 0.0
                midHue = hueOf(midR, midG, midB)
                if (areInCyclicOrder(leftHue, midHue, rightHue)) {
                    if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                        rightR = midR
                        rightG = midG
                        rightB = midB
                        rightHue = midHue
                    } else {
                        leftR = midR
                        leftG = midG
                        leftB = midB
                        leftHue = midHue
                    }
                }

                // update(100.0, (y - 100.0 * Y_FROM_LINRGB_R - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G, 100.0)
                midR = 100.0
                midG = (y - 100.0 * Y_FROM_LINRGB_R - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G
                midB = 100.0
                midHue = hueOf(midR, midG, midB)
                if (areInCyclicOrder(leftHue, midHue, rightHue)) {
                    if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                        rightR = midR
                        rightG = midG
                        rightB = midB
                        rightHue = midHue
                    } else {
                        leftR = midR
                        leftG = midG
                        leftB = midB
                        leftHue = midHue
                    }
                }
            }

            in 92.78..100.0 -> {
                // update((y - 100.0 * Y_FROM_LINRGB_G - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_R, 100.0, 100.0)
                midR = (y - 100.0 * Y_FROM_LINRGB_G - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_R
                midG = 100.0
                midB = 100.0
                midHue = hueOf(midR, midG, midB)
                leftR = midR
                leftG = midG
                leftB = midB
                rightR = midR
                rightG = midG
                rightB = midB
                leftHue = midHue
                rightHue = midHue

                // update(100.0, (y - 100.0 * Y_FROM_LINRGB_R - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G, 100.0)
                midR = 100.0
                midG = (y - 100.0 * Y_FROM_LINRGB_R - 100.0 * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G
                midB = 100.0
                midHue = hueOf(midR, midG, midB)
                if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                    rightR = midR
                    rightG = midG
                    rightB = midB
                    rightHue = midHue
                } else {
                    leftR = midR
                    leftG = midG
                    leftB = midB
                    leftHue = midHue
                }

                // update(100.0, 100.0, (y - 100.0 * Y_FROM_LINRGB_R - 100.0 * Y_FROM_LINRGB_G) / Y_FROM_LINRGB_B)
                midR = 100.0
                midG = 100.0
                midB = (y - 100.0 * Y_FROM_LINRGB_R - 100.0 * Y_FROM_LINRGB_G) / Y_FROM_LINRGB_B
                midHue = hueOf(midR, midG, midB)
                if (areInCyclicOrder(leftHue, midHue, rightHue)) {
                    if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                        rightR = midR
                        rightG = midG
                        rightB = midB
                        rightHue = midHue
                    } else {
                        leftR = midR
                        leftG = midG
                        leftB = midB
                        leftHue = midHue
                    }
                }
            }

            else -> throw IllegalArgumentException("Y value out of range: $y")
        }

        /*for (n in 0..11) {
            val coordA = if (n % 4 <= 1) 0.0 else 100.0
            val coordB = if (n % 2 == 0) 0.0 else 100.0
            if (n < 4) {
                val r = (y - coordA * Y_FROM_LINRGB_G - coordB * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_R
                if (0.0 <= r && r <= 100.0) {
                    midR = r
                    midG = coordA
                    midB = coordB
                } else {
                    continue
                }
            } else if (n < 8) {
                val g = (y - coordB * Y_FROM_LINRGB_R - coordA * Y_FROM_LINRGB_B) / Y_FROM_LINRGB_G
                if (0.0 <= g && g <= 100.0) {
                    midR = coordB
                    midG = g
                    midB = coordA
                } else {
                    continue
                }
            } else {
                val b = (y - coordA * Y_FROM_LINRGB_R - coordB * Y_FROM_LINRGB_G) / Y_FROM_LINRGB_B
                if (0.0 <= b && b <= 100.0) {
                    midR = coordA
                    midG = coordB
                    midB = b
                } else {
                    continue
                }
            }
            val midHue = hueOf(midR, midG, midB)
            if (!initialized) {
                leftR = midR
                leftG = midG
                leftB = midB
                rightR = midR
                rightG = midG
                rightB = midB
                leftHue = midHue
                rightHue = midHue
                initialized = true
            } else if (uncut || areInCyclicOrder(leftHue, midHue, rightHue)) {
                uncut = false
                if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                    rightR = midR
                    rightG = midG
                    rightB = midB
                    rightHue = midHue
                } else {
                    leftR = midR
                    leftG = midG
                    leftB = midB
                    leftHue = midHue
                }
            }
        }*/

        if (leftR != rightR) {
            var lPlane: Int
            var rPlane: Int
            if (leftR < rightR) {
                lPlane = floor(trueDelinearized(leftR) - 0.5).toInt()
                rPlane = ceil(trueDelinearized(rightR) - 0.5).toInt()
            } else {
                lPlane = ceil(trueDelinearized(leftR) - 0.5).toInt()
                rPlane = floor(trueDelinearized(rightR) - 0.5).toInt()
            }
            for (i in 0..7) {
                if (abs(rPlane - lPlane) <= 1) {
                    break
                } else {
                    val mPlane = floor((lPlane + rPlane) / 2.0).toInt()
                    val midPlaneCoordinate = CRITICAL_PLANES[mPlane]
                    val t = (midPlaneCoordinate - leftR) / (rightR - leftR)
                    midR = leftR + (rightR - leftR) * t
                    midG = leftG + (rightG - leftG) * t
                    midB = leftB + (rightB - leftB) * t
                    val midHue = hueOf(midR, midG, midB)
                    if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                        rightR = midR
                        rightG = midG
                        rightB = midB
                        rPlane = mPlane
                    } else {
                        leftR = midR
                        leftG = midG
                        leftB = midB
                        leftHue = midHue
                        lPlane = mPlane
                    }
                }
            }
        }

        if (leftG != rightG) {
            var lPlane: Int
            var rPlane: Int
            if (leftG < rightG) {
                lPlane = floor(trueDelinearized(leftG) - 0.5).toInt()
                rPlane = ceil(trueDelinearized(rightG) - 0.5).toInt()
            } else {
                lPlane = ceil(trueDelinearized(leftG) - 0.5).toInt()
                rPlane = floor(trueDelinearized(rightG) - 0.5).toInt()
            }
            for (i in 0..7) {
                if (abs(rPlane - lPlane) <= 1) {
                    break
                } else {
                    val mPlane = floor((lPlane + rPlane) / 2.0).toInt()
                    val midPlaneCoordinate = CRITICAL_PLANES[mPlane]
                    val t = (midPlaneCoordinate - leftG) / (rightG - leftG)
                    midR = leftR + (rightR - leftR) * t
                    midG = leftG + (rightG - leftG) * t
                    midB = leftB + (rightB - leftB) * t
                    val midHue = hueOf(midR, midG, midB)
                    if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                        rightR = midR
                        rightG = midG
                        rightB = midB
                        rPlane = mPlane
                    } else {
                        leftR = midR
                        leftG = midG
                        leftB = midB
                        leftHue = midHue
                        lPlane = mPlane
                    }
                }
            }
        }

        if (leftB != rightB) {
            var lPlane: Int
            var rPlane: Int
            if (leftB < rightB) {
                lPlane = floor(trueDelinearized(leftB) - 0.5).toInt()
                rPlane = ceil(trueDelinearized(rightB) - 0.5).toInt()
            } else {
                lPlane = ceil(trueDelinearized(leftB) - 0.5).toInt()
                rPlane = floor(trueDelinearized(rightB) - 0.5).toInt()
            }
            for (i in 0..7) {
                if (abs(rPlane - lPlane) <= 1) {
                    break
                } else {
                    val mPlane = floor((lPlane + rPlane) / 2.0).toInt()
                    val midPlaneCoordinate = CRITICAL_PLANES[mPlane]
                    val t = (midPlaneCoordinate - leftB) / (rightB - leftB)
                    midR = leftR + (rightR - leftR) * t
                    midG = leftG + (rightG - leftG) * t
                    midB = leftB + (rightB - leftB) * t
                    val midHue = hueOf(midR, midG, midB)
                    if (areInCyclicOrder(leftHue, targetHue, midHue)) {
                        rightR = midR
                        rightG = midG
                        rightB = midB
                        rPlane = mPlane
                    } else {
                        leftR = midR
                        leftG = midG
                        leftB = midB
                        leftHue = midHue
                        lPlane = mPlane
                    }
                }
            }
        }

        return ColorUtils.argbFromLinrgb((leftR + rightR) / 2, (leftG + rightG) / 2, (leftB + rightB) / 2)
    }

    /**
     * Finds a color with the given hue, chroma, and Y.
     *
     * @param hueRadians The desired hue in radians.
     * @param chroma     The desired chroma.
     * @param y          The desired Y.
     * @return The desired color as a hexadecimal integer, if found; null otherwise.
     */
    @JvmStatic
    private fun findResultByJ(hueRadians: Double, chroma: Double, y: Double): Int? {
        // Initial estimate of j.
        var j = sqrt(y) * 11.0
        // ===========================================================
        // Operations inlined from Cam16 to avoid repeated calculation
        // ===========================================================
        val vc = DefaultViewingConditions
        val tInnerCoeff = 1 / vc.alphaCoeff
        val eHueScaled = cos(hueRadians + 2.0) + 3.8
        val p1 = 12500.0 / 13.0 * vc.ncb * eHueScaled
        val hSin = sin(hueRadians)
        val hCos = cos(hueRadians)
        for (iterationRound in 0..4) {
            // ===========================================================
            // Operations inlined from Cam16 to avoid repeated calculation
            // ===========================================================
            val jNormalized = j / 100.0
            val alpha = chroma / sqrt(jNormalized)
            val t = (alpha * tInnerCoeff).pow(1.0 / 0.9)
            val p2 = vc.aw / vc.nbb * jNormalized.pow(1.0 / vc.c / vc.z)
            val gamma = 23.0 * (p2 + 0.305) * t / (23.0 * p1 + 11.0 * t * hCos + 108.0 * t * hSin)
            val a = gamma * hCos
            val b = gamma * hSin
            val rA = (460.0 * p2 + 451.0 * a + 288.0 * b) / 1403.0
            val gA = (460.0 * p2 - 891.0 * a - 261.0 * b) / 1403.0
            val bA = (460.0 * p2 - 220.0 * a - 6300.0 * b) / 1403.0
            val rAAbs = abs(rA)
            val gAAbs = abs(gA)
            val bAAbs = abs(bA)
            val rCBase = max(0.0, (27.13 * rAAbs) / (400.0 - rAAbs))
            val gCBase = max(0.0, (27.13 * gAAbs) / (400.0 - gAAbs))
            val bCBase = max(0.0, (27.13 * bAAbs) / (400.0 - bAAbs))
            val rCScaled = MathUtils.signum(rA) * rCBase.pow(1.0 / 0.42)
            val gCScaled = MathUtils.signum(gA) * gCBase.pow(1.0 / 0.42)
            val bCScaled = MathUtils.signum(bA) * bCBase.pow(1.0 / 0.42)
            val linrgbR =
                rCScaled * LINRGB_FROM_SCALED_DISCOUNT_11 +
                        gCScaled * LINRGB_FROM_SCALED_DISCOUNT_12 +
                        bCScaled * LINRGB_FROM_SCALED_DISCOUNT_13
            val linrgbG =
                rCScaled * LINRGB_FROM_SCALED_DISCOUNT_21 +
                        gCScaled * LINRGB_FROM_SCALED_DISCOUNT_22 +
                        bCScaled * LINRGB_FROM_SCALED_DISCOUNT_23
            val linrgbB =
                rCScaled * LINRGB_FROM_SCALED_DISCOUNT_31 +
                        gCScaled * LINRGB_FROM_SCALED_DISCOUNT_32 +
                        bCScaled * LINRGB_FROM_SCALED_DISCOUNT_33
            // ===========================================================
            // Operations inlined from Cam16 to avoid repeated calculation
            // ===========================================================
            if (linrgbR < 0 || linrgbG < 0 || linrgbB < 0) {
                return null
            }
            val fnj = Y_FROM_LINRGB_R * linrgbR + Y_FROM_LINRGB_G * linrgbG + Y_FROM_LINRGB_B * linrgbB
            if (fnj <= 0) {
                return null
            }
            if (iterationRound == 4 || abs(fnj - y) < 0.002) {
                if (linrgbR > 100.01 || linrgbG > 100.01 || linrgbB > 100.01) {
                    return null
                }
                return ColorUtils.argbFromLinrgb(linrgbR, linrgbG, linrgbB)
            }
            // Iterates with Newton method,
            // Using 2 * fn(j) / j as the approximation of fn'(j)
            j -= (fnj - y) * j / (2 * fnj)
        }
        return null
    }

    /**
     * Finds an sRGB color with the given hue, chroma, and L*, if possible.
     *
     * @param hueDegrees The desired hue, in degrees.
     * @param chroma     The desired chroma.
     * @param lstar      The desired L*.
     * @return A hexadecimal representing the sRGB color. The color has sufficiently close hue,
     * chroma, and L* to the desired values, if possible; otherwise, the hue and L* will be
     * sufficiently close, and chroma will be maximized.
     */
    @JvmStatic
    fun solveToInt(hueDegrees: Double, chroma: Double, lstar: Double): Int {
        if (chroma < 0.0001 || lstar < 0.0001 || lstar > 99.9999) {
            return ColorUtils.argbFromLstar(lstar)
        }
        val sanitizedHueDegrees = MathUtils.sanitizeDegreesDouble(hueDegrees)
        val hueRadians = Math.toRadians(sanitizedHueDegrees)
        val y = ColorUtils.yFromLstar(lstar)
        val exactAnswer = findResultByJ(hueRadians, chroma, y)
        return exactAnswer ?: bisectToLimit(y, hueRadians)
    }

    @JvmStatic
    fun findChroma(hue: Double, chroma: Double, tone: Double): Double {
        val argb = solveToInt(hue, chroma, tone)

        // ===========================================================
        // Operations inlined from Cam16 to avoid repeated calculation
        // ===========================================================
        val vc = DefaultViewingConditions

        val linrgbR = ColorUtils.linearized(argb shr 16 and 0xFF)
        val linrgbG = ColorUtils.linearized(argb shr 8 and 0xFF)
        val linrgbB = ColorUtils.linearized(argb and 0xFF)

        // Transform XYZ to scaled discounted illuminant
        val rDScaled =
            linrgbR * SCALED_DISCOUNT_FROM_LINRGB_11 +
                    linrgbG * SCALED_DISCOUNT_FROM_LINRGB_12 +
                    linrgbB * SCALED_DISCOUNT_FROM_LINRGB_13
        val gDScaled =
            linrgbR * SCALED_DISCOUNT_FROM_LINRGB_21 +
                    linrgbG * SCALED_DISCOUNT_FROM_LINRGB_22 +
                    linrgbB * SCALED_DISCOUNT_FROM_LINRGB_23
        val bDScaled =
            linrgbR * SCALED_DISCOUNT_FROM_LINRGB_31 +
                    linrgbG * SCALED_DISCOUNT_FROM_LINRGB_32 +
                    linrgbB * SCALED_DISCOUNT_FROM_LINRGB_33

        // Chromatic adaptation
        val rAF = rDScaled.pow(0.42)
        val gAF = gDScaled.pow(0.42)
        val bAF = bDScaled.pow(0.42)
        val rA = 400.0 * rAF / (rAF + 27.13)
        val gA = 400.0 * gAF / (gAF + 27.13)
        val bA = 400.0 * bAF / (bAF + 27.13)

        // redness-greenness
        val a = rA - gA + (bA - gA) / 11.0
        // yellowness-blueness
        val b = (rA + gA - bA - bA) / 9.0

        // auxiliary components
        val u = rA + gA + bA + bA / 20.0
        val p2 = rA + rA + gA + bA / 20.0

        // hue
        val atan2 = atan2(b, a)
        val atanDegrees = Math.toDegrees(atan2)
        val hue =
            if (atanDegrees < 0) {
                atanDegrees + 360.0
            } else {
                if (atanDegrees >= 360) {
                    atanDegrees - 360.0
                } else {
                    atanDegrees
                }
            }

        // CAM16 lightness
        val jNormalizedSqrt = (vc.nbb / vc.aw * p2).pow(vc.c * vc.z / 2.0)

        // CAM16 chroma
        val huePrime = if (hue < 20.14) hue + 360 else hue
        val eHueScaled = cos(Math.toRadians(huePrime) + 2.0) + 3.8
        val p1 = 12500.0 / 13.0 * vc.ncb * eHueScaled
        val t = p1 * hypot(a, b) / (u + 0.305)
        val alpha = vc.alphaCoeff * t.pow(0.9)
        val c = alpha * jNormalizedSqrt
        // ===========================================================
        // Operations inlined from Cam16 to avoid repeated calculation
        // ===========================================================

        return c
    }

    @JvmStatic
    fun findMaxChroma(hue: Double, tone: Double): Double {
        return findChroma(hue, MAX_CHROMA_VALUE, tone)
    }
}
