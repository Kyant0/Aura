/*
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// This file is automatically generated. Do not modify it.
package com.kyant.aura.core.utils

import kotlin.math.pow
import kotlin.math.roundToInt

/**
 * Color science utilities.
 *
 *
 * Utility methods for color science constants and color space conversions that aren't HCT or
 * CAM16.
 */
internal object ColorUtils {
    const val SRGB_TO_XYZ_11 = 0.41233895
    const val SRGB_TO_XYZ_12 = 0.35762064
    const val SRGB_TO_XYZ_13 = 0.18051042
    const val SRGB_TO_XYZ_21 = 0.2126
    const val SRGB_TO_XYZ_22 = 0.7152
    const val SRGB_TO_XYZ_23 = 0.0722
    const val SRGB_TO_XYZ_31 = 0.01932141
    const val SRGB_TO_XYZ_32 = 0.11916382
    const val SRGB_TO_XYZ_33 = 0.95034478

    const val XYZ_TO_SRGB_11 = 3.2413774792388685
    const val XYZ_TO_SRGB_12 = -1.5376652402851851
    const val XYZ_TO_SRGB_13 = -0.49885366846268053
    const val XYZ_TO_SRGB_21 = -0.9691452513005321
    const val XYZ_TO_SRGB_22 = 1.8758853451067872
    const val XYZ_TO_SRGB_23 = 0.04156585616912061
    const val XYZ_TO_SRGB_31 = 0.05562093689691305
    const val XYZ_TO_SRGB_32 = -0.20395524564742123
    const val XYZ_TO_SRGB_33 = 1.0571799111220335

    const val WHITE_POINT_D65_X = 95.047
    const val WHITE_POINT_D65_Y = 100.0
    const val WHITE_POINT_D65_Z = 108.883

    const val Y_FROM_LINRGB_R = 0.2126
    const val Y_FROM_LINRGB_G = 0.7152
    const val Y_FROM_LINRGB_B = 0.0722

    private const val LAB_E = 216.0 / 24389.0
    private const val LAB_KAPPA = 24389.0 / 27.0

    /**
     * Converts a color from RGB components to ARGB format.
     */
    @Suppress("NOTHING_TO_INLINE")
    @JvmStatic
    inline fun argbFromRgb(red: Int, green: Int, blue: Int): Int {
        return (0xFF shl 24) or (red and 0xFF shl 16) or (green and 0xFF shl 8) or (blue and 0xFF)
    }

    /**
     * Converts a color from linear RGB components to ARGB format.
     */
    @Suppress("NOTHING_TO_INLINE")
    @JvmStatic
    inline fun argbFromLinrgb(linrgbR: Double, linrgbG: Double, linrgbB: Double): Int {
        val r = delinearized(linrgbR)
        val g = delinearized(linrgbG)
        val b = delinearized(linrgbB)
        return argbFromRgb(r, g, b)
    }

    /**
     * Converts a color represented in Lab color space into an ARGB integer.
     */
    @JvmStatic
    fun argbFromLab(l: Double, a: Double, b: Double): Int {
        val fy = (l + 16.0) / 116.0
        val fx = a / 500.0 + fy
        val fz = fy - b / 200.0
        val xNormalized = labInvf(fx)
        val yNormalized = labInvf(fy)
        val zNormalized = labInvf(fz)
        val x = xNormalized * WHITE_POINT_D65_X
        val y = yNormalized * WHITE_POINT_D65_Y
        val z = zNormalized * WHITE_POINT_D65_Z
        val linearR = XYZ_TO_SRGB_11 * x + XYZ_TO_SRGB_12 * y + XYZ_TO_SRGB_13 * z
        val linearG = XYZ_TO_SRGB_21 * x + XYZ_TO_SRGB_22 * y + XYZ_TO_SRGB_23 * z
        val linearB = XYZ_TO_SRGB_31 * x + XYZ_TO_SRGB_32 * y + XYZ_TO_SRGB_33 * z
        val r = delinearized(linearR)
        val g = delinearized(linearG)
        val b = delinearized(linearB)
        return argbFromRgb(r, g, b)
    }

    /**
     * Converts a color from ARGB representation to L*a*b* representation.
     *
     * @param argb the ARGB representation of a color
     * @return a Lab object representing the color
     */
    @JvmStatic
    fun labFromArgb(argb: Int): DoubleArray {
        val linearR = linearized(argb shr 16 and 0xFF)
        val linearG = linearized(argb shr 8 and 0xFF)
        val linearB = linearized(argb and 0xFF)
        val x = SRGB_TO_XYZ_11 * linearR + SRGB_TO_XYZ_12 * linearG + SRGB_TO_XYZ_13 * linearB
        val y = SRGB_TO_XYZ_21 * linearR + SRGB_TO_XYZ_22 * linearG + SRGB_TO_XYZ_23 * linearB
        val z = SRGB_TO_XYZ_31 * linearR + SRGB_TO_XYZ_32 * linearG + SRGB_TO_XYZ_33 * linearB
        val xNormalized = x / WHITE_POINT_D65_X
        val yNormalized = y / WHITE_POINT_D65_Y
        val zNormalized = z / WHITE_POINT_D65_Z
        val fx = labF(xNormalized)
        val fy = labF(yNormalized)
        val fz = labF(zNormalized)
        val l = 116.0 * fy - 16
        val a = 500.0 * (fx - fy)
        val b = 200.0 * (fy - fz)
        return doubleArrayOf(l, a, b)
    }

    /**
     * Converts an L* value to an ARGB representation.
     *
     * @param lstar L* in L*a*b*
     * @return ARGB representation of grayscale color with lightness matching L*
     */
    @Suppress("NOTHING_TO_INLINE")
    @JvmStatic
    inline fun argbFromLstar(lstar: Double): Int {
        val y = yFromLstar(lstar)
        val component = delinearized(y)
        return argbFromRgb(component, component, component)
    }

    /**
     * Computes the L* value of a color in ARGB representation.
     *
     * @param argb ARGB representation of a color
     * @return L*, from L*a*b*, coordinate of the color
     */
    @Suppress("NOTHING_TO_INLINE")
    @JvmStatic
    inline fun lstarFromArgb(argb: Int): Double {
        val r = linearized(argb shr 16 and 0xFF)
        val g = linearized(argb shr 8 and 0xFF)
        val b = linearized(argb and 0xFF)
        val y = r * Y_FROM_LINRGB_R + g * Y_FROM_LINRGB_G + b * Y_FROM_LINRGB_B
        return 116.0 * labF(y / 100.0) - 16.0
    }

    /**
     * Converts an L* value to a Y value.
     *
     *
     * L* in L*a*b* and Y in XYZ measure the same quantity, luminance.
     *
     *
     * L* measures perceptual luminance, a linear scale. Y in XYZ measures relative luminance, a
     * logarithmic scale.
     *
     * @param lstar L* in L*a*b*
     * @return Y in XYZ
     */
    @Suppress("NOTHING_TO_INLINE")
    @JvmStatic
    inline fun yFromLstar(lstar: Double): Double {
        return 100.0 * labInvf((lstar + 16.0) / 116.0)
    }

    /**
     * Converts a Y value to an L* value.
     *
     *
     * L* in L*a*b* and Y in XYZ measure the same quantity, luminance.
     *
     *
     * L* measures perceptual luminance, a linear scale. Y in XYZ measures relative luminance, a
     * logarithmic scale.
     *
     * @param y Y in XYZ
     * @return L* in L*a*b*
     */
    @Suppress("NOTHING_TO_INLINE")
    @JvmStatic
    inline fun lstarFromY(y: Double): Double {
        return labF(y / 100.0) * 116.0 - 16.0
    }

    /**
     * Linearizes an RGB component.
     *
     * @param rgbComponent 0 <= rgb_component <= 255, represents R/G/B channel
     * @return 0.0 <= output <= 100.0, color channel converted to linear RGB space
     */
    @Suppress("NOTHING_TO_INLINE")
    @JvmStatic
    inline fun linearized(rgbComponent: Int): Double {
        return if (rgbComponent <= 10.31473368) {
            rgbComponent * 0.030352698354883748
        } else {
            100.0 * ((rgbComponent / 255.0 + 0.055) / 1.055).pow(2.4)
        }
    }

    /**
     * Delinearizes an RGB component.
     *
     * @param rgbComponent 0.0 <= rgb_component <= 100.0, represents linear R/G/B channel
     * @return 0 <= output <= 255, color channel converted to regular RGB space
     */
    @Suppress("NOTHING_TO_INLINE")
    @JvmStatic
    inline fun delinearized(rgbComponent: Double): Int {
        val delinearized =
            if (rgbComponent <= 0.31308) {
                rgbComponent * 32.946
            } else {
                269.025 * (rgbComponent / 100.0).pow(1.0 / 2.4) - 14.025
            }
        return MathUtils.clampInt(0, 255, delinearized.roundToInt())
    }

    @Suppress("NOTHING_TO_INLINE")
    @JvmStatic
    inline fun labF(t: Double): Double {
        return if (t > LAB_E) {
            t.pow(1.0 / 3.0)
        } else {
            (LAB_KAPPA * t + 16) / 116
        }
    }

    @Suppress("NOTHING_TO_INLINE")
    @JvmStatic
    inline fun labInvf(ft: Double): Double {
        val ft3 = ft * ft * ft
        return if (ft3 > LAB_E) {
            ft3
        } else {
            (116 * ft - 16) / LAB_KAPPA
        }
    }
}
